// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                    String    @id @default(cuid())
  name                  String?
  email                 String?   @unique
  emailVerified         DateTime?
  image                 String?
  role                  UserRole  @default(user)
  deletionRequestedAt   DateTime?
  deletionScheduledAt   DateTime?
  accounts              Account[]
  sessions              Session[]
  encryptedOpenAIKey    String?
  openAIKeyIv           String?
  encryptedGoogleKey    String?
  googleKeyIv           String?
  encryptedAnthropicKey String?
  anthropicKeyIv        String?
  chatSessions          ChatSession[]
  skillBooks            SkillBook[]
  activeSkillBookId     String?
  creditBalance         Int                 @default(0)
  creditTransactions    CreditTransaction[]
  activityPoints        Int                 @default(0)
  tierCode              String              @default("bronze")
  activityPointLedgers  UserActivityPointLedger[]
  suggestionThreads     RefDocSuggestionThread[]
  suggestionReplies     RefDocSuggestionReply[]
  suggestionLikes       RefDocSuggestionLike[]
  reviewedSuggestions   RefDocSuggestionReview[] @relation("SuggestionReviewer")
  skillBookFavorites    SkillBookFavorite[]
  skillBookLikes        SkillBookLike[]
}

enum UserRole {
  user
  admin
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model SkillBook {
  id           String   @id @default(cuid())
  name         String
  description  String   @default("")
  instructions String   @db.Text
  documents    String   @default("[]") @db.Text
  source       String   @default("user")
  isPublic     Boolean  @default(false)
  forkedFromId   String?
  forkedFromName String?
  originalAuthor String?
  favorites      SkillBookFavorite[]
  likes          SkillBookLike[]
  authorId     String
  author       User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([authorId])
}

model ChatSession {
  id        String      @id @default(cuid())
  title     String
  provider  String
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  messages  ChatMessage[]
}

model ChatMessage {
  id            String      @id @default(cuid())
  role          String // "user" or "ai"
  content       String
  createdAt     DateTime    @default(now())
  chatSession   ChatSession @relation(fields: [chatSessionId], references: [id], onDelete: Cascade)
  chatSessionId String
}

enum CreditTransactionType {
  purchase
  sale
  listing_fee
  sale_commission
  builder_usage
  admin_adjustment
  listing_fee_burn
  sale_commission_burn
  platform_ai_usage_burn
  sale_settlement_credit
}

model CreditTransaction {
  id           String                @id @default(cuid())
  userId       String
  user         User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  type         CreditTransactionType
  amount       Int
  balanceAfter Int
  description  String                @default("")
  metadataJson String                @default("{}") @db.Text
  createdAt    DateTime              @default(now())

  @@index([userId, createdAt])
}

model UserTier {
  id                        String   @id @default(cuid())
  code                      String   @unique
  displayName               String
  minPoints                 Int      @default(0)
  listingFeeDiscountPct     Int      @default(0)
  saleCommissionDiscountPct Int      @default(0)
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
}

enum ActivityPointSourceType {
  skillbook_download
  skillbook_favorite
  skillbook_like
  doc_suggestion_accepted
  admin_adjustment
}

model UserActivityPointLedger {
  id          String                  @id @default(cuid())
  userId      String
  user        User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  sourceType  ActivityPointSourceType
  sourceId    String?
  points      Int
  reason      String                  @default("")
  metadataJson String                 @default("{}") @db.Text
  createdAt   DateTime                @default(now())

  @@index([userId, createdAt])
}

model SkillBookFavorite {
  id          String   @id @default(cuid())
  skillBookId String
  userId      String
  skillBook   SkillBook @relation(fields: [skillBookId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([skillBookId, userId])
  @@index([skillBookId, createdAt])
}

model SkillBookLike {
  id          String   @id @default(cuid())
  skillBookId String
  userId      String
  skillBook   SkillBook @relation(fields: [skillBookId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([skillBookId, userId])
  @@index([skillBookId, createdAt])
}

enum RefDocSuggestionStatus {
  open
  reviewed
  accepted
  rejected
}

model RefDocSuggestionThread {
  id          String                 @id @default(cuid())
  docSlug     String
  title       String
  body        String                 @db.Text
  status      RefDocSuggestionStatus @default(open)
  authorId    String
  author      User                   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  likes       RefDocSuggestionLike[]
  replies     RefDocSuggestionReply[]
  review      RefDocSuggestionReview?
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt

  @@index([docSlug, createdAt])
  @@index([authorId, createdAt])
}

model RefDocSuggestionReply {
  id         String                 @id @default(cuid())
  threadId   String
  thread     RefDocSuggestionThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  authorId   String
  author     User                   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  body       String                 @db.Text
  createdAt  DateTime               @default(now())

  @@index([threadId, createdAt])
}

model RefDocSuggestionLike {
  id         String                 @id @default(cuid())
  threadId   String
  thread     RefDocSuggestionThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  userId     String
  user       User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt  DateTime               @default(now())

  @@unique([threadId, userId])
  @@index([threadId, createdAt])
}

model RefDocSuggestionReview {
  id               String                 @id @default(cuid())
  threadId         String                 @unique
  thread           RefDocSuggestionThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  reviewerId       String
  reviewer         User                   @relation("SuggestionReviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  decision         RefDocSuggestionStatus
  decisionReason   String                 @default("") @db.Text
  appliedToDoc     Boolean                @default(false)
  linkedDocRevision String?
  createdAt        DateTime               @default(now())
}
